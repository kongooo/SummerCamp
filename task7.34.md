# 7月3日日志  

##

## 阅读Game Programming Patterns.   

### 了解内聚、耦合、解耦等名词  

* 内聚：自己的东西自己保管，自己的事情自己做。  
* 耦合：两个对象之间一方依赖一方的关系。  
* 耦合度：耦合的程度。  
* 解耦合：降低耦合度的过程。 

### 命令模式  

* 将一组行为抽象成对象，从而实现行为请求者与行为实现者之间的松耦合
* 对命令进行封装，将发出命令的责任和执行命令的责任分割开。  

### 享元模式  

* 通过复用内存中已经存在的对象，降低系统创建对象实例的性能消耗。
* 内蕴状态：可以共享，不会随环境改变而改变。
* 外蕴状态：不可共享，会随环境的改变而改变。  

### 观察者模式  

* 对象间的一种一对多的依赖关系。

##

## c#  

### 封装   

* 把一个对象所能操作的所有信息放在一起。
* 减少耦合，保持统一的对外接口，内部修改不影响外部调用。  

### 继承

* 类不允许多重继承，接口允许多重继承
* 派生类可以用new关键字覆盖父类中的方法

### 多态

###### 对于不同类的实例，调用相同的方法，进行不同的操作

######编译时多态：重载 

* 在编译时就会产生相同方法名的不同函数（同一方法定义，传递不同参数）

######运行时多态：重写 

* 在程序运行过程中，依据具体情况来实现不同操作
* 基类中需要重写的函数用virtual定义，派生类中用override定义

### 重载运算符  

* 具有特殊名称的函数
* 定义：类名称 operator 运算符 （参数）
* 有返回类型 

###class与struct 

######struct 

* 不能被继承
* 为值类型 
* 不能声明默认的构造函数

######class 

* 为引用类型
* 可以被继承

### 匿名类型  

* var声明，可以被赋给任意类型的值，但一旦赋值后类型确定不可更改  

### 值类型和引用类型  

* 值类型：存储在栈中，只需要一段单独的内存，用于存储实际的数据，所占内存根据数据类型分配
* 引用类型：需要两段内存，第一段存储实际的数据，存放在堆中，第二段是一个引用，存储在栈中，指向数据在堆中的存放位置，赋值时赋值的是引用类型的引用，也就是改变被赋值对象的指向，所占内存根据数据大小分配（string,array,class)  

### 域、属性和索引器  

###### 域 

* 属于类或对象的变量
* 静态域：只有一个，且被类拥有
* 非静态域：被对象拥有
* 只读域：仅能在初始化时赋值，之后不可更改；既可以是实例域，也可以是静态域；修饰符：readonly

###### 属性  

* 域的一种扩散形式
* 可为静态成员或实例成员
* get访问器没有参数，set访问器仅有值参数   
* 抽象属性需要在派生类中重写

###### 索引器  

* 一种特殊的属性，带有参数
* 声明：用this关键字
* 作用：允许对一个对象本身使用数组表示法来访问该对象内部集合中的元素。
* 必须为实例成员
* get、set（除值参数）访问器具有与索引器相同的形参表  
* 在接口中定义的索引器只需要表明索引器的存在，不需要实现


### 隐藏方法  

* 方法的签名：返回值、参数、方法名
* 当子类中有一个和父类签名相同的方法时，就会把父类方法隐藏
* 重写：父类方法不存在了
* 使用子类声明的对象调用子类的方法，使用父类声明的对象调用父类的隐藏方法  

### this和base  

* this:访问当前类当中的字段和方法（父类和当前类）
* base：只能访问父类中共有的字段和方法 

### 接口和抽象类  

###### 抽象类

* 抽象方法必须在抽象类中
* 继承的抽象类必须实现抽象方法（用override重写）
* 不能利用抽象类构造对象，但可以声明 
* 不能被封装
* 抽象成员不能为私有

###### 接口 

* 成员自动公开，不能包含任何访问修饰符
* 只含方法名，不包含方法体  
* 可以多重继承 

######关系  

* 抽象类是介于接口与类之间的一种特殊的类
* 抽象类在继承接口时，可以实现接口定义的方法，也可以把该方法定义为抽象方法而不去实现 

### 密封类和密封方法 

* 声明：sealed
* 密封类不能被继承，可以被声明在任何类上
* 密封方法不能被重写，只能被声明在重写的方法上  

### 集合类

###### 常见集合类 

* ArrayList：可改变数组长度，提高内存利用率
* Hashtable:对键值的集合
* Queue：先进先出
* Sortedlist：添加时无序，添加后按键值顺序排序，处理速度慢
* Stack：后进先出  

###### 循环列举集合内的元素 

* foreach(类型 迭代变量 in 集合类对象)
* 支持foreach语句的集合必须能够实现集合模式  

### 委托与事件  

###### 委托 

* 定义：修饰符  delegat 类型 名称 （）
* 实例化：委托名 name = new 委托名（事件名）
* 调用：name（）
* 委托的参数和返回类型要与具体委托的方法一致 

###### 委托链 

* name+=方法名 

###### 事件 

* 定义：修饰符 event 委托名称 事件名称  

##

## 总结 

* 学习流程：先看游戏编程模式，但是看不太懂，于是开始学习c#，在网上查资料，后来借了书，就看书做笔记，不懂的上网查资料，由于时间原因没有写代码，所以对于c#只停留在表面上的认识，没有实战经验，还有部分笔记做在了纸上_(:зゝ∠)_。
* 难点：集合类、委托与事件，游戏编程模式
* ps：感觉时间不够了~~o(>_<)o ~~





 
















